// Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  place: (where?: PlaceWhereInput) => Promise<boolean>;
  placeAddRequest: (where?: PlaceAddRequestWhereInput) => Promise<boolean>;
  placeComment: (where?: PlaceCommentWhereInput) => Promise<boolean>;
  placeEditRequest: (where?: PlaceEditRequestWhereInput) => Promise<boolean>;
  placeImage: (where?: PlaceImageWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  place: (where: PlaceWhereUniqueInput) => PlaceNullablePromise;
  places: (args?: {
    where?: PlaceWhereInput;
    orderBy?: PlaceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Place>;
  placesConnection: (args?: {
    where?: PlaceWhereInput;
    orderBy?: PlaceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PlaceConnectionPromise;
  placeAddRequest: (
    where: PlaceAddRequestWhereUniqueInput
  ) => PlaceAddRequestNullablePromise;
  placeAddRequests: (args?: {
    where?: PlaceAddRequestWhereInput;
    orderBy?: PlaceAddRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PlaceAddRequest>;
  placeAddRequestsConnection: (args?: {
    where?: PlaceAddRequestWhereInput;
    orderBy?: PlaceAddRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PlaceAddRequestConnectionPromise;
  placeComment: (
    where: PlaceCommentWhereUniqueInput
  ) => PlaceCommentNullablePromise;
  placeComments: (args?: {
    where?: PlaceCommentWhereInput;
    orderBy?: PlaceCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PlaceComment>;
  placeCommentsConnection: (args?: {
    where?: PlaceCommentWhereInput;
    orderBy?: PlaceCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PlaceCommentConnectionPromise;
  placeEditRequest: (
    where: PlaceEditRequestWhereUniqueInput
  ) => PlaceEditRequestNullablePromise;
  placeEditRequests: (args?: {
    where?: PlaceEditRequestWhereInput;
    orderBy?: PlaceEditRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PlaceEditRequest>;
  placeEditRequestsConnection: (args?: {
    where?: PlaceEditRequestWhereInput;
    orderBy?: PlaceEditRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PlaceEditRequestConnectionPromise;
  placeImage: (where: PlaceImageWhereUniqueInput) => PlaceImageNullablePromise;
  placeImages: (args?: {
    where?: PlaceImageWhereInput;
    orderBy?: PlaceImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PlaceImage>;
  placeImagesConnection: (args?: {
    where?: PlaceImageWhereInput;
    orderBy?: PlaceImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PlaceImageConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createPlace: (data: PlaceCreateInput) => PlacePromise;
  updatePlace: (args: {
    data: PlaceUpdateInput;
    where: PlaceWhereUniqueInput;
  }) => PlacePromise;
  updateManyPlaces: (args: {
    data: PlaceUpdateManyMutationInput;
    where?: PlaceWhereInput;
  }) => BatchPayloadPromise;
  upsertPlace: (args: {
    where: PlaceWhereUniqueInput;
    create: PlaceCreateInput;
    update: PlaceUpdateInput;
  }) => PlacePromise;
  deletePlace: (where: PlaceWhereUniqueInput) => PlacePromise;
  deleteManyPlaces: (where?: PlaceWhereInput) => BatchPayloadPromise;
  createPlaceAddRequest: (
    data: PlaceAddRequestCreateInput
  ) => PlaceAddRequestPromise;
  updatePlaceAddRequest: (args: {
    data: PlaceAddRequestUpdateInput;
    where: PlaceAddRequestWhereUniqueInput;
  }) => PlaceAddRequestPromise;
  updateManyPlaceAddRequests: (args: {
    data: PlaceAddRequestUpdateManyMutationInput;
    where?: PlaceAddRequestWhereInput;
  }) => BatchPayloadPromise;
  upsertPlaceAddRequest: (args: {
    where: PlaceAddRequestWhereUniqueInput;
    create: PlaceAddRequestCreateInput;
    update: PlaceAddRequestUpdateInput;
  }) => PlaceAddRequestPromise;
  deletePlaceAddRequest: (
    where: PlaceAddRequestWhereUniqueInput
  ) => PlaceAddRequestPromise;
  deleteManyPlaceAddRequests: (
    where?: PlaceAddRequestWhereInput
  ) => BatchPayloadPromise;
  createPlaceComment: (data: PlaceCommentCreateInput) => PlaceCommentPromise;
  updatePlaceComment: (args: {
    data: PlaceCommentUpdateInput;
    where: PlaceCommentWhereUniqueInput;
  }) => PlaceCommentPromise;
  updateManyPlaceComments: (args: {
    data: PlaceCommentUpdateManyMutationInput;
    where?: PlaceCommentWhereInput;
  }) => BatchPayloadPromise;
  upsertPlaceComment: (args: {
    where: PlaceCommentWhereUniqueInput;
    create: PlaceCommentCreateInput;
    update: PlaceCommentUpdateInput;
  }) => PlaceCommentPromise;
  deletePlaceComment: (
    where: PlaceCommentWhereUniqueInput
  ) => PlaceCommentPromise;
  deleteManyPlaceComments: (
    where?: PlaceCommentWhereInput
  ) => BatchPayloadPromise;
  createPlaceEditRequest: (
    data: PlaceEditRequestCreateInput
  ) => PlaceEditRequestPromise;
  updatePlaceEditRequest: (args: {
    data: PlaceEditRequestUpdateInput;
    where: PlaceEditRequestWhereUniqueInput;
  }) => PlaceEditRequestPromise;
  updateManyPlaceEditRequests: (args: {
    data: PlaceEditRequestUpdateManyMutationInput;
    where?: PlaceEditRequestWhereInput;
  }) => BatchPayloadPromise;
  upsertPlaceEditRequest: (args: {
    where: PlaceEditRequestWhereUniqueInput;
    create: PlaceEditRequestCreateInput;
    update: PlaceEditRequestUpdateInput;
  }) => PlaceEditRequestPromise;
  deletePlaceEditRequest: (
    where: PlaceEditRequestWhereUniqueInput
  ) => PlaceEditRequestPromise;
  deleteManyPlaceEditRequests: (
    where?: PlaceEditRequestWhereInput
  ) => BatchPayloadPromise;
  createPlaceImage: (data: PlaceImageCreateInput) => PlaceImagePromise;
  updatePlaceImage: (args: {
    data: PlaceImageUpdateInput;
    where: PlaceImageWhereUniqueInput;
  }) => PlaceImagePromise;
  updateManyPlaceImages: (args: {
    data: PlaceImageUpdateManyMutationInput;
    where?: PlaceImageWhereInput;
  }) => BatchPayloadPromise;
  upsertPlaceImage: (args: {
    where: PlaceImageWhereUniqueInput;
    create: PlaceImageCreateInput;
    update: PlaceImageUpdateInput;
  }) => PlaceImagePromise;
  deletePlaceImage: (where: PlaceImageWhereUniqueInput) => PlaceImagePromise;
  deleteManyPlaceImages: (where?: PlaceImageWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  place: (
    where?: PlaceSubscriptionWhereInput
  ) => PlaceSubscriptionPayloadSubscription;
  placeAddRequest: (
    where?: PlaceAddRequestSubscriptionWhereInput
  ) => PlaceAddRequestSubscriptionPayloadSubscription;
  placeComment: (
    where?: PlaceCommentSubscriptionWhereInput
  ) => PlaceCommentSubscriptionPayloadSubscription;
  placeEditRequest: (
    where?: PlaceEditRequestSubscriptionWhereInput
  ) => PlaceEditRequestSubscriptionPayloadSubscription;
  placeImage: (
    where?: PlaceImageSubscriptionWhereInput
  ) => PlaceImageSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type PlaceCommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "rating_ASC"
  | "rating_DESC"
  | "content_ASC"
  | "content_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PlaceImageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "uri_ASC"
  | "uri_DESC";

export type PlaceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "lat_ASC"
  | "lat_DESC"
  | "lng_ASC"
  | "lng_DESC"
  | "name_ASC"
  | "name_DESC"
  | "management_ASC"
  | "management_DESC"
  | "contact_ASC"
  | "contact_DESC"
  | "hours_ASC"
  | "hours_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "uniqId_ASC"
  | "uniqId_DESC"
  | "email_ASC"
  | "email_DESC"
  | "name_ASC"
  | "name_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "age_ASC"
  | "age_DESC"
  | "profileImage_ASC"
  | "profileImage_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PlaceAddRequestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "address_ASC"
  | "address_DESC"
  | "images_ASC"
  | "images_DESC";

export type PlaceEditRequestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "comment_ASC"
  | "comment_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type PlaceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PlaceCommentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  rating?: Maybe<Float>;
  rating_not?: Maybe<Float>;
  rating_in?: Maybe<Float[] | Float>;
  rating_not_in?: Maybe<Float[] | Float>;
  rating_lt?: Maybe<Float>;
  rating_lte?: Maybe<Float>;
  rating_gt?: Maybe<Float>;
  rating_gte?: Maybe<Float>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  place?: Maybe<PlaceWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PlaceCommentWhereInput[] | PlaceCommentWhereInput>;
  OR?: Maybe<PlaceCommentWhereInput[] | PlaceCommentWhereInput>;
  NOT?: Maybe<PlaceCommentWhereInput[] | PlaceCommentWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  uniqId?: Maybe<String>;
  uniqId_not?: Maybe<String>;
  uniqId_in?: Maybe<String[] | String>;
  uniqId_not_in?: Maybe<String[] | String>;
  uniqId_lt?: Maybe<String>;
  uniqId_lte?: Maybe<String>;
  uniqId_gt?: Maybe<String>;
  uniqId_gte?: Maybe<String>;
  uniqId_contains?: Maybe<String>;
  uniqId_not_contains?: Maybe<String>;
  uniqId_starts_with?: Maybe<String>;
  uniqId_not_starts_with?: Maybe<String>;
  uniqId_ends_with?: Maybe<String>;
  uniqId_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  gender?: Maybe<String>;
  gender_not?: Maybe<String>;
  gender_in?: Maybe<String[] | String>;
  gender_not_in?: Maybe<String[] | String>;
  gender_lt?: Maybe<String>;
  gender_lte?: Maybe<String>;
  gender_gt?: Maybe<String>;
  gender_gte?: Maybe<String>;
  gender_contains?: Maybe<String>;
  gender_not_contains?: Maybe<String>;
  gender_starts_with?: Maybe<String>;
  gender_not_starts_with?: Maybe<String>;
  gender_ends_with?: Maybe<String>;
  gender_not_ends_with?: Maybe<String>;
  age?: Maybe<String>;
  age_not?: Maybe<String>;
  age_in?: Maybe<String[] | String>;
  age_not_in?: Maybe<String[] | String>;
  age_lt?: Maybe<String>;
  age_lte?: Maybe<String>;
  age_gt?: Maybe<String>;
  age_gte?: Maybe<String>;
  age_contains?: Maybe<String>;
  age_not_contains?: Maybe<String>;
  age_starts_with?: Maybe<String>;
  age_not_starts_with?: Maybe<String>;
  age_ends_with?: Maybe<String>;
  age_not_ends_with?: Maybe<String>;
  profileImage?: Maybe<String>;
  profileImage_not?: Maybe<String>;
  profileImage_in?: Maybe<String[] | String>;
  profileImage_not_in?: Maybe<String[] | String>;
  profileImage_lt?: Maybe<String>;
  profileImage_lte?: Maybe<String>;
  profileImage_gt?: Maybe<String>;
  profileImage_gte?: Maybe<String>;
  profileImage_contains?: Maybe<String>;
  profileImage_not_contains?: Maybe<String>;
  profileImage_starts_with?: Maybe<String>;
  profileImage_not_starts_with?: Maybe<String>;
  profileImage_ends_with?: Maybe<String>;
  profileImage_not_ends_with?: Maybe<String>;
  images_every?: Maybe<PlaceImageWhereInput>;
  images_some?: Maybe<PlaceImageWhereInput>;
  images_none?: Maybe<PlaceImageWhereInput>;
  comments_every?: Maybe<PlaceCommentWhereInput>;
  comments_some?: Maybe<PlaceCommentWhereInput>;
  comments_none?: Maybe<PlaceCommentWhereInput>;
  bookmark_every?: Maybe<PlaceWhereInput>;
  bookmark_some?: Maybe<PlaceWhereInput>;
  bookmark_none?: Maybe<PlaceWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface PlaceImageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  uri?: Maybe<String>;
  uri_not?: Maybe<String>;
  uri_in?: Maybe<String[] | String>;
  uri_not_in?: Maybe<String[] | String>;
  uri_lt?: Maybe<String>;
  uri_lte?: Maybe<String>;
  uri_gt?: Maybe<String>;
  uri_gte?: Maybe<String>;
  uri_contains?: Maybe<String>;
  uri_not_contains?: Maybe<String>;
  uri_starts_with?: Maybe<String>;
  uri_not_starts_with?: Maybe<String>;
  uri_ends_with?: Maybe<String>;
  uri_not_ends_with?: Maybe<String>;
  place?: Maybe<PlaceWhereInput>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<PlaceImageWhereInput[] | PlaceImageWhereInput>;
  OR?: Maybe<PlaceImageWhereInput[] | PlaceImageWhereInput>;
  NOT?: Maybe<PlaceImageWhereInput[] | PlaceImageWhereInput>;
}

export interface PlaceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  lat?: Maybe<Float>;
  lat_not?: Maybe<Float>;
  lat_in?: Maybe<Float[] | Float>;
  lat_not_in?: Maybe<Float[] | Float>;
  lat_lt?: Maybe<Float>;
  lat_lte?: Maybe<Float>;
  lat_gt?: Maybe<Float>;
  lat_gte?: Maybe<Float>;
  lng?: Maybe<Float>;
  lng_not?: Maybe<Float>;
  lng_in?: Maybe<Float[] | Float>;
  lng_not_in?: Maybe<Float[] | Float>;
  lng_lt?: Maybe<Float>;
  lng_lte?: Maybe<Float>;
  lng_gt?: Maybe<Float>;
  lng_gte?: Maybe<Float>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  management?: Maybe<String>;
  management_not?: Maybe<String>;
  management_in?: Maybe<String[] | String>;
  management_not_in?: Maybe<String[] | String>;
  management_lt?: Maybe<String>;
  management_lte?: Maybe<String>;
  management_gt?: Maybe<String>;
  management_gte?: Maybe<String>;
  management_contains?: Maybe<String>;
  management_not_contains?: Maybe<String>;
  management_starts_with?: Maybe<String>;
  management_not_starts_with?: Maybe<String>;
  management_ends_with?: Maybe<String>;
  management_not_ends_with?: Maybe<String>;
  contact?: Maybe<String>;
  contact_not?: Maybe<String>;
  contact_in?: Maybe<String[] | String>;
  contact_not_in?: Maybe<String[] | String>;
  contact_lt?: Maybe<String>;
  contact_lte?: Maybe<String>;
  contact_gt?: Maybe<String>;
  contact_gte?: Maybe<String>;
  contact_contains?: Maybe<String>;
  contact_not_contains?: Maybe<String>;
  contact_starts_with?: Maybe<String>;
  contact_not_starts_with?: Maybe<String>;
  contact_ends_with?: Maybe<String>;
  contact_not_ends_with?: Maybe<String>;
  hours?: Maybe<String>;
  hours_not?: Maybe<String>;
  hours_in?: Maybe<String[] | String>;
  hours_not_in?: Maybe<String[] | String>;
  hours_lt?: Maybe<String>;
  hours_lte?: Maybe<String>;
  hours_gt?: Maybe<String>;
  hours_gte?: Maybe<String>;
  hours_contains?: Maybe<String>;
  hours_not_contains?: Maybe<String>;
  hours_starts_with?: Maybe<String>;
  hours_not_starts_with?: Maybe<String>;
  hours_ends_with?: Maybe<String>;
  hours_not_ends_with?: Maybe<String>;
  status?: Maybe<String>;
  status_not?: Maybe<String>;
  status_in?: Maybe<String[] | String>;
  status_not_in?: Maybe<String[] | String>;
  status_lt?: Maybe<String>;
  status_lte?: Maybe<String>;
  status_gt?: Maybe<String>;
  status_gte?: Maybe<String>;
  status_contains?: Maybe<String>;
  status_not_contains?: Maybe<String>;
  status_starts_with?: Maybe<String>;
  status_not_starts_with?: Maybe<String>;
  status_ends_with?: Maybe<String>;
  status_not_ends_with?: Maybe<String>;
  comments_every?: Maybe<PlaceCommentWhereInput>;
  comments_some?: Maybe<PlaceCommentWhereInput>;
  comments_none?: Maybe<PlaceCommentWhereInput>;
  images_every?: Maybe<PlaceImageWhereInput>;
  images_some?: Maybe<PlaceImageWhereInput>;
  images_none?: Maybe<PlaceImageWhereInput>;
  bookmark_every?: Maybe<UserWhereInput>;
  bookmark_some?: Maybe<UserWhereInput>;
  bookmark_none?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PlaceWhereInput[] | PlaceWhereInput>;
  OR?: Maybe<PlaceWhereInput[] | PlaceWhereInput>;
  NOT?: Maybe<PlaceWhereInput[] | PlaceWhereInput>;
}

export type PlaceAddRequestWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PlaceAddRequestWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<PlaceAddRequestWhereInput[] | PlaceAddRequestWhereInput>;
  OR?: Maybe<PlaceAddRequestWhereInput[] | PlaceAddRequestWhereInput>;
  NOT?: Maybe<PlaceAddRequestWhereInput[] | PlaceAddRequestWhereInput>;
}

export type PlaceCommentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type PlaceEditRequestWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PlaceEditRequestWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  comment?: Maybe<String>;
  comment_not?: Maybe<String>;
  comment_in?: Maybe<String[] | String>;
  comment_not_in?: Maybe<String[] | String>;
  comment_lt?: Maybe<String>;
  comment_lte?: Maybe<String>;
  comment_gt?: Maybe<String>;
  comment_gte?: Maybe<String>;
  comment_contains?: Maybe<String>;
  comment_not_contains?: Maybe<String>;
  comment_starts_with?: Maybe<String>;
  comment_not_starts_with?: Maybe<String>;
  comment_ends_with?: Maybe<String>;
  comment_not_ends_with?: Maybe<String>;
  place?: Maybe<PlaceWhereInput>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<PlaceEditRequestWhereInput[] | PlaceEditRequestWhereInput>;
  OR?: Maybe<PlaceEditRequestWhereInput[] | PlaceEditRequestWhereInput>;
  NOT?: Maybe<PlaceEditRequestWhereInput[] | PlaceEditRequestWhereInput>;
}

export type PlaceImageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  uniqId?: Maybe<String>;
  email?: Maybe<String>;
}>;

export interface PlaceCreateInput {
  id?: Maybe<ID_Input>;
  lat: Float;
  lng: Float;
  name: String;
  management?: Maybe<String>;
  contact?: Maybe<String>;
  hours?: Maybe<String>;
  status: String;
  comments?: Maybe<PlaceCommentCreateManyWithoutPlaceInput>;
  images?: Maybe<PlaceImageCreateManyWithoutPlaceInput>;
  bookmark?: Maybe<UserCreateManyWithoutBookmarkInput>;
}

export interface PlaceCommentCreateManyWithoutPlaceInput {
  create?: Maybe<
    PlaceCommentCreateWithoutPlaceInput[] | PlaceCommentCreateWithoutPlaceInput
  >;
  connect?: Maybe<
    PlaceCommentWhereUniqueInput[] | PlaceCommentWhereUniqueInput
  >;
}

export interface PlaceCommentCreateWithoutPlaceInput {
  id?: Maybe<ID_Input>;
  rating: Float;
  content: String;
  user: UserCreateOneWithoutCommentsInput;
}

export interface UserCreateOneWithoutCommentsInput {
  create?: Maybe<UserCreateWithoutCommentsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutCommentsInput {
  id?: Maybe<ID_Input>;
  uniqId?: Maybe<String>;
  email: String;
  name: String;
  gender: String;
  age: String;
  profileImage?: Maybe<String>;
  images?: Maybe<PlaceImageCreateManyWithoutUserInput>;
  bookmark?: Maybe<PlaceCreateManyWithoutBookmarkInput>;
}

export interface PlaceImageCreateManyWithoutUserInput {
  create?: Maybe<
    PlaceImageCreateWithoutUserInput[] | PlaceImageCreateWithoutUserInput
  >;
  connect?: Maybe<PlaceImageWhereUniqueInput[] | PlaceImageWhereUniqueInput>;
}

export interface PlaceImageCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  uri: String;
  place: PlaceCreateOneWithoutImagesInput;
}

export interface PlaceCreateOneWithoutImagesInput {
  create?: Maybe<PlaceCreateWithoutImagesInput>;
  connect?: Maybe<PlaceWhereUniqueInput>;
}

export interface PlaceCreateWithoutImagesInput {
  id?: Maybe<ID_Input>;
  lat: Float;
  lng: Float;
  name: String;
  management?: Maybe<String>;
  contact?: Maybe<String>;
  hours?: Maybe<String>;
  status: String;
  comments?: Maybe<PlaceCommentCreateManyWithoutPlaceInput>;
  bookmark?: Maybe<UserCreateManyWithoutBookmarkInput>;
}

export interface UserCreateManyWithoutBookmarkInput {
  create?: Maybe<
    UserCreateWithoutBookmarkInput[] | UserCreateWithoutBookmarkInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutBookmarkInput {
  id?: Maybe<ID_Input>;
  uniqId?: Maybe<String>;
  email: String;
  name: String;
  gender: String;
  age: String;
  profileImage?: Maybe<String>;
  images?: Maybe<PlaceImageCreateManyWithoutUserInput>;
  comments?: Maybe<PlaceCommentCreateManyWithoutUserInput>;
}

export interface PlaceCommentCreateManyWithoutUserInput {
  create?: Maybe<
    PlaceCommentCreateWithoutUserInput[] | PlaceCommentCreateWithoutUserInput
  >;
  connect?: Maybe<
    PlaceCommentWhereUniqueInput[] | PlaceCommentWhereUniqueInput
  >;
}

export interface PlaceCommentCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  rating: Float;
  content: String;
  place: PlaceCreateOneWithoutCommentsInput;
}

export interface PlaceCreateOneWithoutCommentsInput {
  create?: Maybe<PlaceCreateWithoutCommentsInput>;
  connect?: Maybe<PlaceWhereUniqueInput>;
}

export interface PlaceCreateWithoutCommentsInput {
  id?: Maybe<ID_Input>;
  lat: Float;
  lng: Float;
  name: String;
  management?: Maybe<String>;
  contact?: Maybe<String>;
  hours?: Maybe<String>;
  status: String;
  images?: Maybe<PlaceImageCreateManyWithoutPlaceInput>;
  bookmark?: Maybe<UserCreateManyWithoutBookmarkInput>;
}

export interface PlaceImageCreateManyWithoutPlaceInput {
  create?: Maybe<
    PlaceImageCreateWithoutPlaceInput[] | PlaceImageCreateWithoutPlaceInput
  >;
  connect?: Maybe<PlaceImageWhereUniqueInput[] | PlaceImageWhereUniqueInput>;
}

export interface PlaceImageCreateWithoutPlaceInput {
  id?: Maybe<ID_Input>;
  uri: String;
  user: UserCreateOneWithoutImagesInput;
}

export interface UserCreateOneWithoutImagesInput {
  create?: Maybe<UserCreateWithoutImagesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutImagesInput {
  id?: Maybe<ID_Input>;
  uniqId?: Maybe<String>;
  email: String;
  name: String;
  gender: String;
  age: String;
  profileImage?: Maybe<String>;
  comments?: Maybe<PlaceCommentCreateManyWithoutUserInput>;
  bookmark?: Maybe<PlaceCreateManyWithoutBookmarkInput>;
}

export interface PlaceCreateManyWithoutBookmarkInput {
  create?: Maybe<
    PlaceCreateWithoutBookmarkInput[] | PlaceCreateWithoutBookmarkInput
  >;
  connect?: Maybe<PlaceWhereUniqueInput[] | PlaceWhereUniqueInput>;
}

export interface PlaceCreateWithoutBookmarkInput {
  id?: Maybe<ID_Input>;
  lat: Float;
  lng: Float;
  name: String;
  management?: Maybe<String>;
  contact?: Maybe<String>;
  hours?: Maybe<String>;
  status: String;
  comments?: Maybe<PlaceCommentCreateManyWithoutPlaceInput>;
  images?: Maybe<PlaceImageCreateManyWithoutPlaceInput>;
}

export interface PlaceUpdateInput {
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  name?: Maybe<String>;
  management?: Maybe<String>;
  contact?: Maybe<String>;
  hours?: Maybe<String>;
  status?: Maybe<String>;
  comments?: Maybe<PlaceCommentUpdateManyWithoutPlaceInput>;
  images?: Maybe<PlaceImageUpdateManyWithoutPlaceInput>;
  bookmark?: Maybe<UserUpdateManyWithoutBookmarkInput>;
}

export interface PlaceCommentUpdateManyWithoutPlaceInput {
  create?: Maybe<
    PlaceCommentCreateWithoutPlaceInput[] | PlaceCommentCreateWithoutPlaceInput
  >;
  delete?: Maybe<PlaceCommentWhereUniqueInput[] | PlaceCommentWhereUniqueInput>;
  connect?: Maybe<
    PlaceCommentWhereUniqueInput[] | PlaceCommentWhereUniqueInput
  >;
  set?: Maybe<PlaceCommentWhereUniqueInput[] | PlaceCommentWhereUniqueInput>;
  disconnect?: Maybe<
    PlaceCommentWhereUniqueInput[] | PlaceCommentWhereUniqueInput
  >;
  update?: Maybe<
    | PlaceCommentUpdateWithWhereUniqueWithoutPlaceInput[]
    | PlaceCommentUpdateWithWhereUniqueWithoutPlaceInput
  >;
  upsert?: Maybe<
    | PlaceCommentUpsertWithWhereUniqueWithoutPlaceInput[]
    | PlaceCommentUpsertWithWhereUniqueWithoutPlaceInput
  >;
  deleteMany?: Maybe<
    PlaceCommentScalarWhereInput[] | PlaceCommentScalarWhereInput
  >;
  updateMany?: Maybe<
    | PlaceCommentUpdateManyWithWhereNestedInput[]
    | PlaceCommentUpdateManyWithWhereNestedInput
  >;
}

export interface PlaceCommentUpdateWithWhereUniqueWithoutPlaceInput {
  where: PlaceCommentWhereUniqueInput;
  data: PlaceCommentUpdateWithoutPlaceDataInput;
}

export interface PlaceCommentUpdateWithoutPlaceDataInput {
  rating?: Maybe<Float>;
  content?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutCommentsInput>;
}

export interface UserUpdateOneRequiredWithoutCommentsInput {
  create?: Maybe<UserCreateWithoutCommentsInput>;
  update?: Maybe<UserUpdateWithoutCommentsDataInput>;
  upsert?: Maybe<UserUpsertWithoutCommentsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutCommentsDataInput {
  uniqId?: Maybe<String>;
  email?: Maybe<String>;
  name?: Maybe<String>;
  gender?: Maybe<String>;
  age?: Maybe<String>;
  profileImage?: Maybe<String>;
  images?: Maybe<PlaceImageUpdateManyWithoutUserInput>;
  bookmark?: Maybe<PlaceUpdateManyWithoutBookmarkInput>;
}

export interface PlaceImageUpdateManyWithoutUserInput {
  create?: Maybe<
    PlaceImageCreateWithoutUserInput[] | PlaceImageCreateWithoutUserInput
  >;
  delete?: Maybe<PlaceImageWhereUniqueInput[] | PlaceImageWhereUniqueInput>;
  connect?: Maybe<PlaceImageWhereUniqueInput[] | PlaceImageWhereUniqueInput>;
  set?: Maybe<PlaceImageWhereUniqueInput[] | PlaceImageWhereUniqueInput>;
  disconnect?: Maybe<PlaceImageWhereUniqueInput[] | PlaceImageWhereUniqueInput>;
  update?: Maybe<
    | PlaceImageUpdateWithWhereUniqueWithoutUserInput[]
    | PlaceImageUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | PlaceImageUpsertWithWhereUniqueWithoutUserInput[]
    | PlaceImageUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<PlaceImageScalarWhereInput[] | PlaceImageScalarWhereInput>;
  updateMany?: Maybe<
    | PlaceImageUpdateManyWithWhereNestedInput[]
    | PlaceImageUpdateManyWithWhereNestedInput
  >;
}

export interface PlaceImageUpdateWithWhereUniqueWithoutUserInput {
  where: PlaceImageWhereUniqueInput;
  data: PlaceImageUpdateWithoutUserDataInput;
}

export interface PlaceImageUpdateWithoutUserDataInput {
  uri?: Maybe<String>;
  place?: Maybe<PlaceUpdateOneRequiredWithoutImagesInput>;
}

export interface PlaceUpdateOneRequiredWithoutImagesInput {
  create?: Maybe<PlaceCreateWithoutImagesInput>;
  update?: Maybe<PlaceUpdateWithoutImagesDataInput>;
  upsert?: Maybe<PlaceUpsertWithoutImagesInput>;
  connect?: Maybe<PlaceWhereUniqueInput>;
}

export interface PlaceUpdateWithoutImagesDataInput {
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  name?: Maybe<String>;
  management?: Maybe<String>;
  contact?: Maybe<String>;
  hours?: Maybe<String>;
  status?: Maybe<String>;
  comments?: Maybe<PlaceCommentUpdateManyWithoutPlaceInput>;
  bookmark?: Maybe<UserUpdateManyWithoutBookmarkInput>;
}

export interface UserUpdateManyWithoutBookmarkInput {
  create?: Maybe<
    UserCreateWithoutBookmarkInput[] | UserCreateWithoutBookmarkInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutBookmarkInput[]
    | UserUpdateWithWhereUniqueWithoutBookmarkInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutBookmarkInput[]
    | UserUpsertWithWhereUniqueWithoutBookmarkInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutBookmarkInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutBookmarkDataInput;
}

export interface UserUpdateWithoutBookmarkDataInput {
  uniqId?: Maybe<String>;
  email?: Maybe<String>;
  name?: Maybe<String>;
  gender?: Maybe<String>;
  age?: Maybe<String>;
  profileImage?: Maybe<String>;
  images?: Maybe<PlaceImageUpdateManyWithoutUserInput>;
  comments?: Maybe<PlaceCommentUpdateManyWithoutUserInput>;
}

export interface PlaceCommentUpdateManyWithoutUserInput {
  create?: Maybe<
    PlaceCommentCreateWithoutUserInput[] | PlaceCommentCreateWithoutUserInput
  >;
  delete?: Maybe<PlaceCommentWhereUniqueInput[] | PlaceCommentWhereUniqueInput>;
  connect?: Maybe<
    PlaceCommentWhereUniqueInput[] | PlaceCommentWhereUniqueInput
  >;
  set?: Maybe<PlaceCommentWhereUniqueInput[] | PlaceCommentWhereUniqueInput>;
  disconnect?: Maybe<
    PlaceCommentWhereUniqueInput[] | PlaceCommentWhereUniqueInput
  >;
  update?: Maybe<
    | PlaceCommentUpdateWithWhereUniqueWithoutUserInput[]
    | PlaceCommentUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | PlaceCommentUpsertWithWhereUniqueWithoutUserInput[]
    | PlaceCommentUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    PlaceCommentScalarWhereInput[] | PlaceCommentScalarWhereInput
  >;
  updateMany?: Maybe<
    | PlaceCommentUpdateManyWithWhereNestedInput[]
    | PlaceCommentUpdateManyWithWhereNestedInput
  >;
}

export interface PlaceCommentUpdateWithWhereUniqueWithoutUserInput {
  where: PlaceCommentWhereUniqueInput;
  data: PlaceCommentUpdateWithoutUserDataInput;
}

export interface PlaceCommentUpdateWithoutUserDataInput {
  rating?: Maybe<Float>;
  content?: Maybe<String>;
  place?: Maybe<PlaceUpdateOneRequiredWithoutCommentsInput>;
}

export interface PlaceUpdateOneRequiredWithoutCommentsInput {
  create?: Maybe<PlaceCreateWithoutCommentsInput>;
  update?: Maybe<PlaceUpdateWithoutCommentsDataInput>;
  upsert?: Maybe<PlaceUpsertWithoutCommentsInput>;
  connect?: Maybe<PlaceWhereUniqueInput>;
}

export interface PlaceUpdateWithoutCommentsDataInput {
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  name?: Maybe<String>;
  management?: Maybe<String>;
  contact?: Maybe<String>;
  hours?: Maybe<String>;
  status?: Maybe<String>;
  images?: Maybe<PlaceImageUpdateManyWithoutPlaceInput>;
  bookmark?: Maybe<UserUpdateManyWithoutBookmarkInput>;
}

export interface PlaceImageUpdateManyWithoutPlaceInput {
  create?: Maybe<
    PlaceImageCreateWithoutPlaceInput[] | PlaceImageCreateWithoutPlaceInput
  >;
  delete?: Maybe<PlaceImageWhereUniqueInput[] | PlaceImageWhereUniqueInput>;
  connect?: Maybe<PlaceImageWhereUniqueInput[] | PlaceImageWhereUniqueInput>;
  set?: Maybe<PlaceImageWhereUniqueInput[] | PlaceImageWhereUniqueInput>;
  disconnect?: Maybe<PlaceImageWhereUniqueInput[] | PlaceImageWhereUniqueInput>;
  update?: Maybe<
    | PlaceImageUpdateWithWhereUniqueWithoutPlaceInput[]
    | PlaceImageUpdateWithWhereUniqueWithoutPlaceInput
  >;
  upsert?: Maybe<
    | PlaceImageUpsertWithWhereUniqueWithoutPlaceInput[]
    | PlaceImageUpsertWithWhereUniqueWithoutPlaceInput
  >;
  deleteMany?: Maybe<PlaceImageScalarWhereInput[] | PlaceImageScalarWhereInput>;
  updateMany?: Maybe<
    | PlaceImageUpdateManyWithWhereNestedInput[]
    | PlaceImageUpdateManyWithWhereNestedInput
  >;
}

export interface PlaceImageUpdateWithWhereUniqueWithoutPlaceInput {
  where: PlaceImageWhereUniqueInput;
  data: PlaceImageUpdateWithoutPlaceDataInput;
}

export interface PlaceImageUpdateWithoutPlaceDataInput {
  uri?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutImagesInput>;
}

export interface UserUpdateOneRequiredWithoutImagesInput {
  create?: Maybe<UserCreateWithoutImagesInput>;
  update?: Maybe<UserUpdateWithoutImagesDataInput>;
  upsert?: Maybe<UserUpsertWithoutImagesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutImagesDataInput {
  uniqId?: Maybe<String>;
  email?: Maybe<String>;
  name?: Maybe<String>;
  gender?: Maybe<String>;
  age?: Maybe<String>;
  profileImage?: Maybe<String>;
  comments?: Maybe<PlaceCommentUpdateManyWithoutUserInput>;
  bookmark?: Maybe<PlaceUpdateManyWithoutBookmarkInput>;
}

export interface PlaceUpdateManyWithoutBookmarkInput {
  create?: Maybe<
    PlaceCreateWithoutBookmarkInput[] | PlaceCreateWithoutBookmarkInput
  >;
  delete?: Maybe<PlaceWhereUniqueInput[] | PlaceWhereUniqueInput>;
  connect?: Maybe<PlaceWhereUniqueInput[] | PlaceWhereUniqueInput>;
  set?: Maybe<PlaceWhereUniqueInput[] | PlaceWhereUniqueInput>;
  disconnect?: Maybe<PlaceWhereUniqueInput[] | PlaceWhereUniqueInput>;
  update?: Maybe<
    | PlaceUpdateWithWhereUniqueWithoutBookmarkInput[]
    | PlaceUpdateWithWhereUniqueWithoutBookmarkInput
  >;
  upsert?: Maybe<
    | PlaceUpsertWithWhereUniqueWithoutBookmarkInput[]
    | PlaceUpsertWithWhereUniqueWithoutBookmarkInput
  >;
  deleteMany?: Maybe<PlaceScalarWhereInput[] | PlaceScalarWhereInput>;
  updateMany?: Maybe<
    PlaceUpdateManyWithWhereNestedInput[] | PlaceUpdateManyWithWhereNestedInput
  >;
}

export interface PlaceUpdateWithWhereUniqueWithoutBookmarkInput {
  where: PlaceWhereUniqueInput;
  data: PlaceUpdateWithoutBookmarkDataInput;
}

export interface PlaceUpdateWithoutBookmarkDataInput {
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  name?: Maybe<String>;
  management?: Maybe<String>;
  contact?: Maybe<String>;
  hours?: Maybe<String>;
  status?: Maybe<String>;
  comments?: Maybe<PlaceCommentUpdateManyWithoutPlaceInput>;
  images?: Maybe<PlaceImageUpdateManyWithoutPlaceInput>;
}

export interface PlaceUpsertWithWhereUniqueWithoutBookmarkInput {
  where: PlaceWhereUniqueInput;
  update: PlaceUpdateWithoutBookmarkDataInput;
  create: PlaceCreateWithoutBookmarkInput;
}

export interface PlaceScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  lat?: Maybe<Float>;
  lat_not?: Maybe<Float>;
  lat_in?: Maybe<Float[] | Float>;
  lat_not_in?: Maybe<Float[] | Float>;
  lat_lt?: Maybe<Float>;
  lat_lte?: Maybe<Float>;
  lat_gt?: Maybe<Float>;
  lat_gte?: Maybe<Float>;
  lng?: Maybe<Float>;
  lng_not?: Maybe<Float>;
  lng_in?: Maybe<Float[] | Float>;
  lng_not_in?: Maybe<Float[] | Float>;
  lng_lt?: Maybe<Float>;
  lng_lte?: Maybe<Float>;
  lng_gt?: Maybe<Float>;
  lng_gte?: Maybe<Float>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  management?: Maybe<String>;
  management_not?: Maybe<String>;
  management_in?: Maybe<String[] | String>;
  management_not_in?: Maybe<String[] | String>;
  management_lt?: Maybe<String>;
  management_lte?: Maybe<String>;
  management_gt?: Maybe<String>;
  management_gte?: Maybe<String>;
  management_contains?: Maybe<String>;
  management_not_contains?: Maybe<String>;
  management_starts_with?: Maybe<String>;
  management_not_starts_with?: Maybe<String>;
  management_ends_with?: Maybe<String>;
  management_not_ends_with?: Maybe<String>;
  contact?: Maybe<String>;
  contact_not?: Maybe<String>;
  contact_in?: Maybe<String[] | String>;
  contact_not_in?: Maybe<String[] | String>;
  contact_lt?: Maybe<String>;
  contact_lte?: Maybe<String>;
  contact_gt?: Maybe<String>;
  contact_gte?: Maybe<String>;
  contact_contains?: Maybe<String>;
  contact_not_contains?: Maybe<String>;
  contact_starts_with?: Maybe<String>;
  contact_not_starts_with?: Maybe<String>;
  contact_ends_with?: Maybe<String>;
  contact_not_ends_with?: Maybe<String>;
  hours?: Maybe<String>;
  hours_not?: Maybe<String>;
  hours_in?: Maybe<String[] | String>;
  hours_not_in?: Maybe<String[] | String>;
  hours_lt?: Maybe<String>;
  hours_lte?: Maybe<String>;
  hours_gt?: Maybe<String>;
  hours_gte?: Maybe<String>;
  hours_contains?: Maybe<String>;
  hours_not_contains?: Maybe<String>;
  hours_starts_with?: Maybe<String>;
  hours_not_starts_with?: Maybe<String>;
  hours_ends_with?: Maybe<String>;
  hours_not_ends_with?: Maybe<String>;
  status?: Maybe<String>;
  status_not?: Maybe<String>;
  status_in?: Maybe<String[] | String>;
  status_not_in?: Maybe<String[] | String>;
  status_lt?: Maybe<String>;
  status_lte?: Maybe<String>;
  status_gt?: Maybe<String>;
  status_gte?: Maybe<String>;
  status_contains?: Maybe<String>;
  status_not_contains?: Maybe<String>;
  status_starts_with?: Maybe<String>;
  status_not_starts_with?: Maybe<String>;
  status_ends_with?: Maybe<String>;
  status_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PlaceScalarWhereInput[] | PlaceScalarWhereInput>;
  OR?: Maybe<PlaceScalarWhereInput[] | PlaceScalarWhereInput>;
  NOT?: Maybe<PlaceScalarWhereInput[] | PlaceScalarWhereInput>;
}

export interface PlaceUpdateManyWithWhereNestedInput {
  where: PlaceScalarWhereInput;
  data: PlaceUpdateManyDataInput;
}

export interface PlaceUpdateManyDataInput {
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  name?: Maybe<String>;
  management?: Maybe<String>;
  contact?: Maybe<String>;
  hours?: Maybe<String>;
  status?: Maybe<String>;
}

export interface UserUpsertWithoutImagesInput {
  update: UserUpdateWithoutImagesDataInput;
  create: UserCreateWithoutImagesInput;
}

export interface PlaceImageUpsertWithWhereUniqueWithoutPlaceInput {
  where: PlaceImageWhereUniqueInput;
  update: PlaceImageUpdateWithoutPlaceDataInput;
  create: PlaceImageCreateWithoutPlaceInput;
}

export interface PlaceImageScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  uri?: Maybe<String>;
  uri_not?: Maybe<String>;
  uri_in?: Maybe<String[] | String>;
  uri_not_in?: Maybe<String[] | String>;
  uri_lt?: Maybe<String>;
  uri_lte?: Maybe<String>;
  uri_gt?: Maybe<String>;
  uri_gte?: Maybe<String>;
  uri_contains?: Maybe<String>;
  uri_not_contains?: Maybe<String>;
  uri_starts_with?: Maybe<String>;
  uri_not_starts_with?: Maybe<String>;
  uri_ends_with?: Maybe<String>;
  uri_not_ends_with?: Maybe<String>;
  AND?: Maybe<PlaceImageScalarWhereInput[] | PlaceImageScalarWhereInput>;
  OR?: Maybe<PlaceImageScalarWhereInput[] | PlaceImageScalarWhereInput>;
  NOT?: Maybe<PlaceImageScalarWhereInput[] | PlaceImageScalarWhereInput>;
}

export interface PlaceImageUpdateManyWithWhereNestedInput {
  where: PlaceImageScalarWhereInput;
  data: PlaceImageUpdateManyDataInput;
}

export interface PlaceImageUpdateManyDataInput {
  uri?: Maybe<String>;
}

export interface PlaceUpsertWithoutCommentsInput {
  update: PlaceUpdateWithoutCommentsDataInput;
  create: PlaceCreateWithoutCommentsInput;
}

export interface PlaceCommentUpsertWithWhereUniqueWithoutUserInput {
  where: PlaceCommentWhereUniqueInput;
  update: PlaceCommentUpdateWithoutUserDataInput;
  create: PlaceCommentCreateWithoutUserInput;
}

export interface PlaceCommentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  rating?: Maybe<Float>;
  rating_not?: Maybe<Float>;
  rating_in?: Maybe<Float[] | Float>;
  rating_not_in?: Maybe<Float[] | Float>;
  rating_lt?: Maybe<Float>;
  rating_lte?: Maybe<Float>;
  rating_gt?: Maybe<Float>;
  rating_gte?: Maybe<Float>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PlaceCommentScalarWhereInput[] | PlaceCommentScalarWhereInput>;
  OR?: Maybe<PlaceCommentScalarWhereInput[] | PlaceCommentScalarWhereInput>;
  NOT?: Maybe<PlaceCommentScalarWhereInput[] | PlaceCommentScalarWhereInput>;
}

export interface PlaceCommentUpdateManyWithWhereNestedInput {
  where: PlaceCommentScalarWhereInput;
  data: PlaceCommentUpdateManyDataInput;
}

export interface PlaceCommentUpdateManyDataInput {
  rating?: Maybe<Float>;
  content?: Maybe<String>;
}

export interface UserUpsertWithWhereUniqueWithoutBookmarkInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutBookmarkDataInput;
  create: UserCreateWithoutBookmarkInput;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  uniqId?: Maybe<String>;
  uniqId_not?: Maybe<String>;
  uniqId_in?: Maybe<String[] | String>;
  uniqId_not_in?: Maybe<String[] | String>;
  uniqId_lt?: Maybe<String>;
  uniqId_lte?: Maybe<String>;
  uniqId_gt?: Maybe<String>;
  uniqId_gte?: Maybe<String>;
  uniqId_contains?: Maybe<String>;
  uniqId_not_contains?: Maybe<String>;
  uniqId_starts_with?: Maybe<String>;
  uniqId_not_starts_with?: Maybe<String>;
  uniqId_ends_with?: Maybe<String>;
  uniqId_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  gender?: Maybe<String>;
  gender_not?: Maybe<String>;
  gender_in?: Maybe<String[] | String>;
  gender_not_in?: Maybe<String[] | String>;
  gender_lt?: Maybe<String>;
  gender_lte?: Maybe<String>;
  gender_gt?: Maybe<String>;
  gender_gte?: Maybe<String>;
  gender_contains?: Maybe<String>;
  gender_not_contains?: Maybe<String>;
  gender_starts_with?: Maybe<String>;
  gender_not_starts_with?: Maybe<String>;
  gender_ends_with?: Maybe<String>;
  gender_not_ends_with?: Maybe<String>;
  age?: Maybe<String>;
  age_not?: Maybe<String>;
  age_in?: Maybe<String[] | String>;
  age_not_in?: Maybe<String[] | String>;
  age_lt?: Maybe<String>;
  age_lte?: Maybe<String>;
  age_gt?: Maybe<String>;
  age_gte?: Maybe<String>;
  age_contains?: Maybe<String>;
  age_not_contains?: Maybe<String>;
  age_starts_with?: Maybe<String>;
  age_not_starts_with?: Maybe<String>;
  age_ends_with?: Maybe<String>;
  age_not_ends_with?: Maybe<String>;
  profileImage?: Maybe<String>;
  profileImage_not?: Maybe<String>;
  profileImage_in?: Maybe<String[] | String>;
  profileImage_not_in?: Maybe<String[] | String>;
  profileImage_lt?: Maybe<String>;
  profileImage_lte?: Maybe<String>;
  profileImage_gt?: Maybe<String>;
  profileImage_gte?: Maybe<String>;
  profileImage_contains?: Maybe<String>;
  profileImage_not_contains?: Maybe<String>;
  profileImage_starts_with?: Maybe<String>;
  profileImage_not_starts_with?: Maybe<String>;
  profileImage_ends_with?: Maybe<String>;
  profileImage_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  uniqId?: Maybe<String>;
  email?: Maybe<String>;
  name?: Maybe<String>;
  gender?: Maybe<String>;
  age?: Maybe<String>;
  profileImage?: Maybe<String>;
}

export interface PlaceUpsertWithoutImagesInput {
  update: PlaceUpdateWithoutImagesDataInput;
  create: PlaceCreateWithoutImagesInput;
}

export interface PlaceImageUpsertWithWhereUniqueWithoutUserInput {
  where: PlaceImageWhereUniqueInput;
  update: PlaceImageUpdateWithoutUserDataInput;
  create: PlaceImageCreateWithoutUserInput;
}

export interface UserUpsertWithoutCommentsInput {
  update: UserUpdateWithoutCommentsDataInput;
  create: UserCreateWithoutCommentsInput;
}

export interface PlaceCommentUpsertWithWhereUniqueWithoutPlaceInput {
  where: PlaceCommentWhereUniqueInput;
  update: PlaceCommentUpdateWithoutPlaceDataInput;
  create: PlaceCommentCreateWithoutPlaceInput;
}

export interface PlaceUpdateManyMutationInput {
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  name?: Maybe<String>;
  management?: Maybe<String>;
  contact?: Maybe<String>;
  hours?: Maybe<String>;
  status?: Maybe<String>;
}

export interface PlaceAddRequestCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  address: String;
  images: Json;
  user: UserCreateOneInput;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  uniqId?: Maybe<String>;
  email: String;
  name: String;
  gender: String;
  age: String;
  profileImage?: Maybe<String>;
  images?: Maybe<PlaceImageCreateManyWithoutUserInput>;
  comments?: Maybe<PlaceCommentCreateManyWithoutUserInput>;
  bookmark?: Maybe<PlaceCreateManyWithoutBookmarkInput>;
}

export interface PlaceAddRequestUpdateInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
  images?: Maybe<Json>;
  user?: Maybe<UserUpdateOneRequiredInput>;
}

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateDataInput {
  uniqId?: Maybe<String>;
  email?: Maybe<String>;
  name?: Maybe<String>;
  gender?: Maybe<String>;
  age?: Maybe<String>;
  profileImage?: Maybe<String>;
  images?: Maybe<PlaceImageUpdateManyWithoutUserInput>;
  comments?: Maybe<PlaceCommentUpdateManyWithoutUserInput>;
  bookmark?: Maybe<PlaceUpdateManyWithoutBookmarkInput>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface PlaceAddRequestUpdateManyMutationInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
  images?: Maybe<Json>;
}

export interface PlaceCommentCreateInput {
  id?: Maybe<ID_Input>;
  rating: Float;
  content: String;
  user: UserCreateOneWithoutCommentsInput;
  place: PlaceCreateOneWithoutCommentsInput;
}

export interface PlaceCommentUpdateInput {
  rating?: Maybe<Float>;
  content?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutCommentsInput>;
  place?: Maybe<PlaceUpdateOneRequiredWithoutCommentsInput>;
}

export interface PlaceCommentUpdateManyMutationInput {
  rating?: Maybe<Float>;
  content?: Maybe<String>;
}

export interface PlaceEditRequestCreateInput {
  id?: Maybe<ID_Input>;
  comment: String;
  place: PlaceCreateOneInput;
  user: UserCreateOneInput;
}

export interface PlaceCreateOneInput {
  create?: Maybe<PlaceCreateInput>;
  connect?: Maybe<PlaceWhereUniqueInput>;
}

export interface PlaceEditRequestUpdateInput {
  comment?: Maybe<String>;
  place?: Maybe<PlaceUpdateOneRequiredInput>;
  user?: Maybe<UserUpdateOneRequiredInput>;
}

export interface PlaceUpdateOneRequiredInput {
  create?: Maybe<PlaceCreateInput>;
  update?: Maybe<PlaceUpdateDataInput>;
  upsert?: Maybe<PlaceUpsertNestedInput>;
  connect?: Maybe<PlaceWhereUniqueInput>;
}

export interface PlaceUpdateDataInput {
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  name?: Maybe<String>;
  management?: Maybe<String>;
  contact?: Maybe<String>;
  hours?: Maybe<String>;
  status?: Maybe<String>;
  comments?: Maybe<PlaceCommentUpdateManyWithoutPlaceInput>;
  images?: Maybe<PlaceImageUpdateManyWithoutPlaceInput>;
  bookmark?: Maybe<UserUpdateManyWithoutBookmarkInput>;
}

export interface PlaceUpsertNestedInput {
  update: PlaceUpdateDataInput;
  create: PlaceCreateInput;
}

export interface PlaceEditRequestUpdateManyMutationInput {
  comment?: Maybe<String>;
}

export interface PlaceImageCreateInput {
  id?: Maybe<ID_Input>;
  uri: String;
  place: PlaceCreateOneWithoutImagesInput;
  user: UserCreateOneWithoutImagesInput;
}

export interface PlaceImageUpdateInput {
  uri?: Maybe<String>;
  place?: Maybe<PlaceUpdateOneRequiredWithoutImagesInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutImagesInput>;
}

export interface PlaceImageUpdateManyMutationInput {
  uri?: Maybe<String>;
}

export interface UserUpdateInput {
  uniqId?: Maybe<String>;
  email?: Maybe<String>;
  name?: Maybe<String>;
  gender?: Maybe<String>;
  age?: Maybe<String>;
  profileImage?: Maybe<String>;
  images?: Maybe<PlaceImageUpdateManyWithoutUserInput>;
  comments?: Maybe<PlaceCommentUpdateManyWithoutUserInput>;
  bookmark?: Maybe<PlaceUpdateManyWithoutBookmarkInput>;
}

export interface UserUpdateManyMutationInput {
  uniqId?: Maybe<String>;
  email?: Maybe<String>;
  name?: Maybe<String>;
  gender?: Maybe<String>;
  age?: Maybe<String>;
  profileImage?: Maybe<String>;
}

export interface PlaceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PlaceWhereInput>;
  AND?: Maybe<PlaceSubscriptionWhereInput[] | PlaceSubscriptionWhereInput>;
  OR?: Maybe<PlaceSubscriptionWhereInput[] | PlaceSubscriptionWhereInput>;
  NOT?: Maybe<PlaceSubscriptionWhereInput[] | PlaceSubscriptionWhereInput>;
}

export interface PlaceAddRequestSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PlaceAddRequestWhereInput>;
  AND?: Maybe<
    | PlaceAddRequestSubscriptionWhereInput[]
    | PlaceAddRequestSubscriptionWhereInput
  >;
  OR?: Maybe<
    | PlaceAddRequestSubscriptionWhereInput[]
    | PlaceAddRequestSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PlaceAddRequestSubscriptionWhereInput[]
    | PlaceAddRequestSubscriptionWhereInput
  >;
}

export interface PlaceCommentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PlaceCommentWhereInput>;
  AND?: Maybe<
    PlaceCommentSubscriptionWhereInput[] | PlaceCommentSubscriptionWhereInput
  >;
  OR?: Maybe<
    PlaceCommentSubscriptionWhereInput[] | PlaceCommentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    PlaceCommentSubscriptionWhereInput[] | PlaceCommentSubscriptionWhereInput
  >;
}

export interface PlaceEditRequestSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PlaceEditRequestWhereInput>;
  AND?: Maybe<
    | PlaceEditRequestSubscriptionWhereInput[]
    | PlaceEditRequestSubscriptionWhereInput
  >;
  OR?: Maybe<
    | PlaceEditRequestSubscriptionWhereInput[]
    | PlaceEditRequestSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PlaceEditRequestSubscriptionWhereInput[]
    | PlaceEditRequestSubscriptionWhereInput
  >;
}

export interface PlaceImageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PlaceImageWhereInput>;
  AND?: Maybe<
    PlaceImageSubscriptionWhereInput[] | PlaceImageSubscriptionWhereInput
  >;
  OR?: Maybe<
    PlaceImageSubscriptionWhereInput[] | PlaceImageSubscriptionWhereInput
  >;
  NOT?: Maybe<
    PlaceImageSubscriptionWhereInput[] | PlaceImageSubscriptionWhereInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Place {
  id: ID_Output;
  lat: Float;
  lng: Float;
  name: String;
  management?: String;
  contact?: String;
  hours?: String;
  status: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PlacePromise extends Promise<Place>, Fragmentable {
  id: () => Promise<ID_Output>;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  name: () => Promise<String>;
  management: () => Promise<String>;
  contact: () => Promise<String>;
  hours: () => Promise<String>;
  status: () => Promise<String>;
  comments: <T = FragmentableArray<PlaceComment>>(args?: {
    where?: PlaceCommentWhereInput;
    orderBy?: PlaceCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  images: <T = FragmentableArray<PlaceImage>>(args?: {
    where?: PlaceImageWhereInput;
    orderBy?: PlaceImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bookmark: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PlaceSubscription
  extends Promise<AsyncIterator<Place>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  lat: () => Promise<AsyncIterator<Float>>;
  lng: () => Promise<AsyncIterator<Float>>;
  name: () => Promise<AsyncIterator<String>>;
  management: () => Promise<AsyncIterator<String>>;
  contact: () => Promise<AsyncIterator<String>>;
  hours: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<String>>;
  comments: <T = Promise<AsyncIterator<PlaceCommentSubscription>>>(args?: {
    where?: PlaceCommentWhereInput;
    orderBy?: PlaceCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  images: <T = Promise<AsyncIterator<PlaceImageSubscription>>>(args?: {
    where?: PlaceImageWhereInput;
    orderBy?: PlaceImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bookmark: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PlaceNullablePromise
  extends Promise<Place | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  name: () => Promise<String>;
  management: () => Promise<String>;
  contact: () => Promise<String>;
  hours: () => Promise<String>;
  status: () => Promise<String>;
  comments: <T = FragmentableArray<PlaceComment>>(args?: {
    where?: PlaceCommentWhereInput;
    orderBy?: PlaceCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  images: <T = FragmentableArray<PlaceImage>>(args?: {
    where?: PlaceImageWhereInput;
    orderBy?: PlaceImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bookmark: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PlaceComment {
  id: ID_Output;
  rating: Float;
  content: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PlaceCommentPromise
  extends Promise<PlaceComment>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  rating: () => Promise<Float>;
  content: () => Promise<String>;
  user: <T = UserPromise>() => T;
  place: <T = PlacePromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PlaceCommentSubscription
  extends Promise<AsyncIterator<PlaceComment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  rating: () => Promise<AsyncIterator<Float>>;
  content: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  place: <T = PlaceSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PlaceCommentNullablePromise
  extends Promise<PlaceComment | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  rating: () => Promise<Float>;
  content: () => Promise<String>;
  user: <T = UserPromise>() => T;
  place: <T = PlacePromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface User {
  id: ID_Output;
  uniqId?: String;
  email: String;
  name: String;
  gender: String;
  age: String;
  profileImage: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  uniqId: () => Promise<String>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  gender: () => Promise<String>;
  age: () => Promise<String>;
  profileImage: () => Promise<String>;
  images: <T = FragmentableArray<PlaceImage>>(args?: {
    where?: PlaceImageWhereInput;
    orderBy?: PlaceImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<PlaceComment>>(args?: {
    where?: PlaceCommentWhereInput;
    orderBy?: PlaceCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bookmark: <T = FragmentableArray<Place>>(args?: {
    where?: PlaceWhereInput;
    orderBy?: PlaceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  uniqId: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  age: () => Promise<AsyncIterator<String>>;
  profileImage: () => Promise<AsyncIterator<String>>;
  images: <T = Promise<AsyncIterator<PlaceImageSubscription>>>(args?: {
    where?: PlaceImageWhereInput;
    orderBy?: PlaceImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = Promise<AsyncIterator<PlaceCommentSubscription>>>(args?: {
    where?: PlaceCommentWhereInput;
    orderBy?: PlaceCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bookmark: <T = Promise<AsyncIterator<PlaceSubscription>>>(args?: {
    where?: PlaceWhereInput;
    orderBy?: PlaceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  uniqId: () => Promise<String>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  gender: () => Promise<String>;
  age: () => Promise<String>;
  profileImage: () => Promise<String>;
  images: <T = FragmentableArray<PlaceImage>>(args?: {
    where?: PlaceImageWhereInput;
    orderBy?: PlaceImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<PlaceComment>>(args?: {
    where?: PlaceCommentWhereInput;
    orderBy?: PlaceCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bookmark: <T = FragmentableArray<Place>>(args?: {
    where?: PlaceWhereInput;
    orderBy?: PlaceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PlaceImage {
  id: ID_Output;
  uri: String;
}

export interface PlaceImagePromise extends Promise<PlaceImage>, Fragmentable {
  id: () => Promise<ID_Output>;
  uri: () => Promise<String>;
  place: <T = PlacePromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface PlaceImageSubscription
  extends Promise<AsyncIterator<PlaceImage>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  uri: () => Promise<AsyncIterator<String>>;
  place: <T = PlaceSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface PlaceImageNullablePromise
  extends Promise<PlaceImage | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  uri: () => Promise<String>;
  place: <T = PlacePromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface PlaceConnection {
  pageInfo: PageInfo;
  edges: PlaceEdge[];
}

export interface PlaceConnectionPromise
  extends Promise<PlaceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlaceEdge>>() => T;
  aggregate: <T = AggregatePlacePromise>() => T;
}

export interface PlaceConnectionSubscription
  extends Promise<AsyncIterator<PlaceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlaceEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlaceSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface PlaceEdge {
  node: Place;
  cursor: String;
}

export interface PlaceEdgePromise extends Promise<PlaceEdge>, Fragmentable {
  node: <T = PlacePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlaceEdgeSubscription
  extends Promise<AsyncIterator<PlaceEdge>>,
    Fragmentable {
  node: <T = PlaceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePlace {
  count: Int;
}

export interface AggregatePlacePromise
  extends Promise<AggregatePlace>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlaceSubscription
  extends Promise<AsyncIterator<AggregatePlace>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PlaceAddRequest {
  id: ID_Output;
  name: String;
  address: String;
  images: Json;
}

export interface PlaceAddRequestPromise
  extends Promise<PlaceAddRequest>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  address: () => Promise<String>;
  images: () => Promise<Json>;
  user: <T = UserPromise>() => T;
}

export interface PlaceAddRequestSubscription
  extends Promise<AsyncIterator<PlaceAddRequest>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  images: () => Promise<AsyncIterator<Json>>;
  user: <T = UserSubscription>() => T;
}

export interface PlaceAddRequestNullablePromise
  extends Promise<PlaceAddRequest | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  address: () => Promise<String>;
  images: () => Promise<Json>;
  user: <T = UserPromise>() => T;
}

export interface PlaceAddRequestConnection {
  pageInfo: PageInfo;
  edges: PlaceAddRequestEdge[];
}

export interface PlaceAddRequestConnectionPromise
  extends Promise<PlaceAddRequestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlaceAddRequestEdge>>() => T;
  aggregate: <T = AggregatePlaceAddRequestPromise>() => T;
}

export interface PlaceAddRequestConnectionSubscription
  extends Promise<AsyncIterator<PlaceAddRequestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlaceAddRequestEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlaceAddRequestSubscription>() => T;
}

export interface PlaceAddRequestEdge {
  node: PlaceAddRequest;
  cursor: String;
}

export interface PlaceAddRequestEdgePromise
  extends Promise<PlaceAddRequestEdge>,
    Fragmentable {
  node: <T = PlaceAddRequestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlaceAddRequestEdgeSubscription
  extends Promise<AsyncIterator<PlaceAddRequestEdge>>,
    Fragmentable {
  node: <T = PlaceAddRequestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePlaceAddRequest {
  count: Int;
}

export interface AggregatePlaceAddRequestPromise
  extends Promise<AggregatePlaceAddRequest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlaceAddRequestSubscription
  extends Promise<AsyncIterator<AggregatePlaceAddRequest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PlaceCommentConnection {
  pageInfo: PageInfo;
  edges: PlaceCommentEdge[];
}

export interface PlaceCommentConnectionPromise
  extends Promise<PlaceCommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlaceCommentEdge>>() => T;
  aggregate: <T = AggregatePlaceCommentPromise>() => T;
}

export interface PlaceCommentConnectionSubscription
  extends Promise<AsyncIterator<PlaceCommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlaceCommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlaceCommentSubscription>() => T;
}

export interface PlaceCommentEdge {
  node: PlaceComment;
  cursor: String;
}

export interface PlaceCommentEdgePromise
  extends Promise<PlaceCommentEdge>,
    Fragmentable {
  node: <T = PlaceCommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlaceCommentEdgeSubscription
  extends Promise<AsyncIterator<PlaceCommentEdge>>,
    Fragmentable {
  node: <T = PlaceCommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePlaceComment {
  count: Int;
}

export interface AggregatePlaceCommentPromise
  extends Promise<AggregatePlaceComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlaceCommentSubscription
  extends Promise<AsyncIterator<AggregatePlaceComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PlaceEditRequest {
  id: ID_Output;
  comment: String;
}

export interface PlaceEditRequestPromise
  extends Promise<PlaceEditRequest>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  comment: () => Promise<String>;
  place: <T = PlacePromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface PlaceEditRequestSubscription
  extends Promise<AsyncIterator<PlaceEditRequest>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  comment: () => Promise<AsyncIterator<String>>;
  place: <T = PlaceSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface PlaceEditRequestNullablePromise
  extends Promise<PlaceEditRequest | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  comment: () => Promise<String>;
  place: <T = PlacePromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface PlaceEditRequestConnection {
  pageInfo: PageInfo;
  edges: PlaceEditRequestEdge[];
}

export interface PlaceEditRequestConnectionPromise
  extends Promise<PlaceEditRequestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlaceEditRequestEdge>>() => T;
  aggregate: <T = AggregatePlaceEditRequestPromise>() => T;
}

export interface PlaceEditRequestConnectionSubscription
  extends Promise<AsyncIterator<PlaceEditRequestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlaceEditRequestEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlaceEditRequestSubscription>() => T;
}

export interface PlaceEditRequestEdge {
  node: PlaceEditRequest;
  cursor: String;
}

export interface PlaceEditRequestEdgePromise
  extends Promise<PlaceEditRequestEdge>,
    Fragmentable {
  node: <T = PlaceEditRequestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlaceEditRequestEdgeSubscription
  extends Promise<AsyncIterator<PlaceEditRequestEdge>>,
    Fragmentable {
  node: <T = PlaceEditRequestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePlaceEditRequest {
  count: Int;
}

export interface AggregatePlaceEditRequestPromise
  extends Promise<AggregatePlaceEditRequest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlaceEditRequestSubscription
  extends Promise<AsyncIterator<AggregatePlaceEditRequest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PlaceImageConnection {
  pageInfo: PageInfo;
  edges: PlaceImageEdge[];
}

export interface PlaceImageConnectionPromise
  extends Promise<PlaceImageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlaceImageEdge>>() => T;
  aggregate: <T = AggregatePlaceImagePromise>() => T;
}

export interface PlaceImageConnectionSubscription
  extends Promise<AsyncIterator<PlaceImageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlaceImageEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlaceImageSubscription>() => T;
}

export interface PlaceImageEdge {
  node: PlaceImage;
  cursor: String;
}

export interface PlaceImageEdgePromise
  extends Promise<PlaceImageEdge>,
    Fragmentable {
  node: <T = PlaceImagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlaceImageEdgeSubscription
  extends Promise<AsyncIterator<PlaceImageEdge>>,
    Fragmentable {
  node: <T = PlaceImageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePlaceImage {
  count: Int;
}

export interface AggregatePlaceImagePromise
  extends Promise<AggregatePlaceImage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlaceImageSubscription
  extends Promise<AsyncIterator<AggregatePlaceImage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface PlaceSubscriptionPayload {
  mutation: MutationType;
  node: Place;
  updatedFields: String[];
  previousValues: PlacePreviousValues;
}

export interface PlaceSubscriptionPayloadPromise
  extends Promise<PlaceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlacePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlacePreviousValuesPromise>() => T;
}

export interface PlaceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlaceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlaceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlacePreviousValuesSubscription>() => T;
}

export interface PlacePreviousValues {
  id: ID_Output;
  lat: Float;
  lng: Float;
  name: String;
  management?: String;
  contact?: String;
  hours?: String;
  status: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PlacePreviousValuesPromise
  extends Promise<PlacePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  name: () => Promise<String>;
  management: () => Promise<String>;
  contact: () => Promise<String>;
  hours: () => Promise<String>;
  status: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PlacePreviousValuesSubscription
  extends Promise<AsyncIterator<PlacePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  lat: () => Promise<AsyncIterator<Float>>;
  lng: () => Promise<AsyncIterator<Float>>;
  name: () => Promise<AsyncIterator<String>>;
  management: () => Promise<AsyncIterator<String>>;
  contact: () => Promise<AsyncIterator<String>>;
  hours: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PlaceAddRequestSubscriptionPayload {
  mutation: MutationType;
  node: PlaceAddRequest;
  updatedFields: String[];
  previousValues: PlaceAddRequestPreviousValues;
}

export interface PlaceAddRequestSubscriptionPayloadPromise
  extends Promise<PlaceAddRequestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlaceAddRequestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlaceAddRequestPreviousValuesPromise>() => T;
}

export interface PlaceAddRequestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlaceAddRequestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlaceAddRequestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlaceAddRequestPreviousValuesSubscription>() => T;
}

export interface PlaceAddRequestPreviousValues {
  id: ID_Output;
  name: String;
  address: String;
  images: Json;
}

export interface PlaceAddRequestPreviousValuesPromise
  extends Promise<PlaceAddRequestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  address: () => Promise<String>;
  images: () => Promise<Json>;
}

export interface PlaceAddRequestPreviousValuesSubscription
  extends Promise<AsyncIterator<PlaceAddRequestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  images: () => Promise<AsyncIterator<Json>>;
}

export interface PlaceCommentSubscriptionPayload {
  mutation: MutationType;
  node: PlaceComment;
  updatedFields: String[];
  previousValues: PlaceCommentPreviousValues;
}

export interface PlaceCommentSubscriptionPayloadPromise
  extends Promise<PlaceCommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlaceCommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlaceCommentPreviousValuesPromise>() => T;
}

export interface PlaceCommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlaceCommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlaceCommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlaceCommentPreviousValuesSubscription>() => T;
}

export interface PlaceCommentPreviousValues {
  id: ID_Output;
  rating: Float;
  content: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PlaceCommentPreviousValuesPromise
  extends Promise<PlaceCommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  rating: () => Promise<Float>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PlaceCommentPreviousValuesSubscription
  extends Promise<AsyncIterator<PlaceCommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  rating: () => Promise<AsyncIterator<Float>>;
  content: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PlaceEditRequestSubscriptionPayload {
  mutation: MutationType;
  node: PlaceEditRequest;
  updatedFields: String[];
  previousValues: PlaceEditRequestPreviousValues;
}

export interface PlaceEditRequestSubscriptionPayloadPromise
  extends Promise<PlaceEditRequestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlaceEditRequestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlaceEditRequestPreviousValuesPromise>() => T;
}

export interface PlaceEditRequestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlaceEditRequestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlaceEditRequestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlaceEditRequestPreviousValuesSubscription>() => T;
}

export interface PlaceEditRequestPreviousValues {
  id: ID_Output;
  comment: String;
}

export interface PlaceEditRequestPreviousValuesPromise
  extends Promise<PlaceEditRequestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  comment: () => Promise<String>;
}

export interface PlaceEditRequestPreviousValuesSubscription
  extends Promise<AsyncIterator<PlaceEditRequestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  comment: () => Promise<AsyncIterator<String>>;
}

export interface PlaceImageSubscriptionPayload {
  mutation: MutationType;
  node: PlaceImage;
  updatedFields: String[];
  previousValues: PlaceImagePreviousValues;
}

export interface PlaceImageSubscriptionPayloadPromise
  extends Promise<PlaceImageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlaceImagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlaceImagePreviousValuesPromise>() => T;
}

export interface PlaceImageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlaceImageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlaceImageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlaceImagePreviousValuesSubscription>() => T;
}

export interface PlaceImagePreviousValues {
  id: ID_Output;
  uri: String;
}

export interface PlaceImagePreviousValuesPromise
  extends Promise<PlaceImagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  uri: () => Promise<String>;
}

export interface PlaceImagePreviousValuesSubscription
  extends Promise<AsyncIterator<PlaceImagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  uri: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  uniqId?: String;
  email: String;
  name: String;
  gender: String;
  age: String;
  profileImage: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  uniqId: () => Promise<String>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  gender: () => Promise<String>;
  age: () => Promise<String>;
  profileImage: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  uniqId: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  age: () => Promise<AsyncIterator<String>>;
  profileImage: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Json = any;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Place",
    embedded: false
  },
  {
    name: "PlaceComment",
    embedded: false
  },
  {
    name: "PlaceImage",
    embedded: false
  },
  {
    name: "PlaceAddRequest",
    embedded: false
  },
  {
    name: "PlaceEditRequest",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
